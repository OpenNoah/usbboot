// Generated by DriverWizard version DriverStudio 3.1.0 (Build 1722)
//
// This console application demonstrates how to open a handle
// to a device in your driver, and communicate with the driver
// using Read, Write, and DeviceIoControl calls, as appropriate.
//
// This test program attempts to open the device using the
 
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winioctl.h>
#include <time.h>
#include "Usb_Boot_Interface.h" 
#include "Usb_Boot_Ioctl.h"	   
#include "Usb_Boot_defines.h"
#include "USB_Boot_API.h"
 
extern HANDLE OpenByInterface(GUID* pClassGuid, DWORD instance, PDWORD pError);

int JZ4740_USB_GET_CPU_INFO(HANDLE hDevice);
int JZ4740_USB_SET_DATA_ADDRESS(unsigned int addr,HANDLE	hDevice);
int JZ4740_USB_SET_DATA_LENGTH(unsigned int len,HANDLE hDevice);
int JZ4740_USB_FLUSH_CACHES(HANDLE hDevice);
int JZ4740_USB_PROG_START1(unsigned int addr,HANDLE hDevice);
int JZ4740_USB_PROG_START2(unsigned int addr,HANDLE hDevice);
int JZ4740_USB_NOR_OPS(unsigned int ops,HANDLE hDevice);
int JZ4740_USB_NAND_OPS(unsigned int ops,HANDLE hDevice);
int JZ4740_USB_SDRAM_OPS(unsigned int ops,HANDLE hDevice);
int JZ4740_USB_CONFIGRATION(unsigned int ops,HANDLE hDevice);
int JZ4740_USB_GET_NUM(HANDLE	hDevice);

 HANDLE	hDevice = INVALID_HANDLE_VALUE;
 GUID ClassGuid = Jz4740_usbDevice_CLASS_GUID;

// Global data
#define N_IOCODES	10//6
char *IOnames[N_IOCODES+1] =
{
	"JZ4740_USB_IOCTL_GET_CPU_INFO",
	"JZ4740_USB_IOCTL_SET_DATA_ADDRESS",
	"JZ4740_USB_IOCTL_SET_DATA_LENGTH",
	"JZ4740_USB_IOCTL_FLUSH_CACHES",
	"JZ4740_USB_IOCTL_PROG_START1",
	"JZ4740_USB_IOCTL_PROG_START2",
	"JZ4740_USB_IOCTL_NOR_OPS",
	"JZ4740_USB_IOCTL_NAND_OPS",
	"JZ4740_USB_IOCTL_CONFIGRATION",
	"JZ4740_USB_IOCTL_GET_NUM",
	""
};

// IOCTL codes
//
int IOcodes[N_IOCODES+1] =
{
	JZ4740_USB_IOCTL_GET_CPU_INFO,
	JZ4740_USB_IOCTL_SET_DATA_ADDRESS,
	JZ4740_USB_IOCTL_SET_DATA_LENGTH,
	JZ4740_USB_IOCTL_FLUSH_CACHES,
	JZ4740_USB_IOCTL_PROG_START1,
	JZ4740_USB_IOCTL_PROG_START2,
	JZ4740_USB_IOCTL_NOR_OPS,
	JZ4740_USB_IOCTL_NAND_OPS,
	JZ4740_USB_IOCTL_CONFIGRATION,
	JZ4740_USB_IOCTL_GET_NUM,
	0
};

const char NAND_SECTION[][30]=
{
	/* NAND section */
	"BUSWIDTH",			//The width of the NAND flash chip in bits (8|16|32)
	"ROWCYCLES",		//The row address cycles (2|3)
	"PAGESIZE",			//The page size of the NAND chip in bytes
	"PAGEPERBLOCK",		//The page number per block
	"FORCEERASE",
	"PLANENUM",
	"OOBSIZE",
	"ECCPOS",
	"BADBLACKPOS",
	"BADBLACKPAGE",

	/* PLL section */
	"EXTCLK",			//Define the external crystal in MHz No.10
	"CPUSPEED",			//Define the PLL output frequency
	"PHMDIV",			//Define the frequency divider ratio of Pll=CCLK:PCLK=HCLK=MCLK
	"BOUDRATE",			//Define the uart boudrate
	"USEUART",			//Use which uart, 0/1 for jz4740,0/1/2/3 for jz4750

	/* SDRAM section */
	"SDRAMWIDTH",		//Define the SDRAM bus width 32/16 No.15
	"BANKS",			//Define the SDRAM bank number 2/4
	"ROWADDR",			//Define the SDRAM row address 11 to 13
	"COLADDR",			//Define the SDRAM row address 8 to 12
	"ISMOBILE",			//Define whether SDRAM is mobile SDRAM, this only valid for Jz4750
	"ISBUSSHARE",		//Define whether SDRAM bus share with NAND 1:shared 0:unshared

	"BCHBIT",
	"WPPIN",
	"BLOCKPERCHIP",

	"LAST_ONE",
};

const char IMAGE_TYPE[][30]=
{
	"with oob and ecc",
	"with oob and without ecc",
	"without oob",
};

DWORD	Error;
short err;
unsigned char ret[8];
hand_t Hand,*hand_p;
ULONG nWritten,nRead;
extern unsigned char code_buf[4 * 512 * 1024];
unsigned char check_buf[4 * 512 * 1024];
int wait_delay = 0x7ffffff;
unsigned int total_size;

void dump_data(unsigned char *p, int size)
{
	int i;
	for (i = 0; i < size; i ++)
	{
		if (i % 16 == 0) printf("\n");
		printf("%2x ",p[i]);
	}
}

int Handle_Open(int obj)
{
	hDevice = OpenByInterface( &ClassGuid, obj, &Error);
	if (hDevice == INVALID_HANDLE_VALUE) return -1;
	else return 1;
}

int Handle_Close(void)
{
	if (hDevice != INVALID_HANDLE_VALUE)
	{
		// Close the handle to the driver
		if (!CloseHandle(hDevice))
		{
			//printf("ERROR: CloseHandle returns %0x.\n", GetLastError());
			return -1;
		}
	}
		hDevice = INVALID_HANDLE_VALUE;
	return 1;
}

int Error_Check(unsigned char *org,unsigned char * obj,unsigned int size)
{
	unsigned int i;
	//printf(" %d:%d ",org[0],obj[0]);
	for (i=0;i<size;i++)
	{
		//printf(" %d:%d ",org[i],obj[i]);
		if (org[i]!=obj[i]) 
		{
			printf("\n Check Error! %d=%x:%x ",i,org[i],obj[i]);
			return 0;
		}
	}
	//printf("\n Check pass");
	return 1;
}

void Error_Handle(unsigned int err)
{
}

int Check_Dump_CFG()
{
#if 0                   //just for debug
	/* dump the configuration file data  */
	printf("\next_clk				:%d \n\
cpu_speed			:%d \n\
phm_div				:%d \n\
use_uart			:%d \n\
boudrate			:%d \n\
bus_width			:%d \n\
bank_num			:%d \n\
row_addr			:%d \n\
col_addr			:%d \n\
is_mobile			:%d \n\
is_busshare			:%d \n\
nand_bw				:%d \n\
nand_rc				:%d \n\
nand_ps				:%d \n\
nand_ppb			:%d \n\
nand_force_erase		:%d \n\
nand_pn				:%d \n\
nand_os				:%d \n\
nand_eccpos			:%d \n\
nand_bbpage			:%d \n\
nand_bbpos			:%d \n ",		\
			Hand.fw_args.ext_clk,		\
			Hand.fw_args.cpu_speed,		\
			Hand.fw_args.phm_div,		\
			Hand.fw_args.use_uart,		\
			Hand.fw_args.boudrate,		\
			Hand.fw_args.bus_width,		\
			Hand.fw_args.bank_num,		\
			Hand.fw_args.row_addr,		\
			Hand.fw_args.col_addr,		\
			Hand.fw_args.is_mobile,		\
			Hand.fw_args.is_busshare,		\
			Hand.nand_bw,		\
			Hand.nand_rc,		\
			Hand.nand_ps,		\
			Hand.nand_ppb,		\
			Hand.nand_force_erase,		\
			Hand.nand_pn,		\
			Hand.nand_os,		\
			Hand.nand_eccpos,		\
			Hand.nand_bbpage,		\
			Hand.nand_bbpos);		
#endif
	printf("\n Now checking whether all configure args valid: ");
	/* check PLL */
	if ( Hand.fw_args.ext_clk > 27 || Hand.fw_args.ext_clk < 12 )
	{
		printf("\n EXTCLK setting invalid!");
		return 0;
	}
	if ( Hand.fw_args.phm_div > 32 || Hand.fw_args.ext_clk < 2 )
	{
		printf("\n PHMDIV setting invalid!");
		return 0;
	}
	if ( (Hand.fw_args.cpu_speed * Hand.fw_args.ext_clk ) % 12 != 0 )
	{
		printf("\n CPUSPEED setting invalid!");
		return 0;
	}

	/* check SDRAM */
	if ( Hand.fw_args.bus_width > 1 )
	{
		printf("\n SDRAMWIDTH setting invalid!");
		return 0;
	}
	if ( Hand.fw_args.bank_num > 1 )
	{
		printf("\n BANKNUM setting invalid!");
		return 0;
	}
	if ( Hand.fw_args.row_addr > 13 && Hand.fw_args.row_addr < 11 )
	{
		printf("\n ROWADDR setting invalid!");
		return 0;
	}
	if ( Hand.fw_args.col_addr > 13 && Hand.fw_args.col_addr < 11 )
	{
		printf("\n COLADDR setting invalid!");
		return 0;
	}

	/* check NAND */
	if ( Hand.nand_ps < 2048 && Hand.nand_os > 16 )
	{
		printf("\n PAGESIZE or OOBSIZE setting invalid!");
		return 0;
	}
	if ( Hand.nand_ps < 2048 && Hand.nand_ppb > 32 )
	{
		printf("\n PAGESIZE or PAGEPERBLOCK setting invalid!");
		return 0;
	}

	if ( Hand.nand_ps > 512 && Hand.nand_os <= 16 )
	{
		printf("\n PAGESIZE or OOBSIZE setting invalid!");
		return 0;
	}
	if ( Hand.nand_ps > 512 && Hand.nand_ppb < 64 )
	{
		printf("\n PAGESIZE or PAGEPERBLOCK setting invalid!");
		return 0;
	}

	printf("\n Current device information:");
	printf(" CPU is Jz%x",Hand.fw_args.cpu_id);
	printf("\n Crystal work at %dMHz, the CCLK up to %dMHz and PMH_CLK up to %dMHz",
		Hand.fw_args.ext_clk,
		(unsigned int)Hand.fw_args.cpu_speed * Hand.fw_args.ext_clk,
		((unsigned int)Hand.fw_args.cpu_speed * Hand.fw_args.ext_clk) / Hand.fw_args.phm_div);

	printf("\n Total SDRAM size is %d MB, work in %d bank and %d bit mode",
		total_size / 0x100000, 2 * (Hand.fw_args.bank_num + 1), 16 * (2 - Hand.fw_args.bus_width));

	printf("\n Nand page size %d, ECC offset %d, ",
		Hand.nand_ps,Hand.nand_eccpos);

	printf("bad block ID %d, ",Hand.nand_bbpage);

	printf("use %d plane mode",Hand.nand_plane);

	return 1;
}

int Read_Load_CFG(char * fname)
{
	FILE *fp;
	char line[100];
	unsigned short i,j;
	unsigned long temp;
	if ((fp=fopen(fname,"rt"))==NULL)
	{
		printf("\n Can not open configration file!");
		return 0;
	}

#if 0	
	while(!strstr(line,"[FLASH]"))
	{
		if (feof(fp))
		{
			printf("\n USBBoot.cfg is bad!");
			return -1;
		}
		fgets(line,100,fp);
	}
#endif

	while(!strstr(line,"[PLL]"))
	{
		if (feof(fp))
		{
			printf("\n USBBoot.cfg is bad!");
			return -1;
		}
		fgets(line,100,fp);
		//printf("\n %s",line);
	}
	/* Load [PLL] section here */
	while(!strstr(line,"[SDRAM]"))
	{
		if (feof(fp))
		{
			printf("\n USBBoot.cfg is bad!");
			return -1;
		}
		fgets(line,100,fp);
		for (i=0;i<strlen(line);i++)
			if (line[i]==';') line[i]='\0';
		//printf("\n %s",line);
		for (i=0;i<NAND_SECTION_NUM;i++)
			if (strstr(line,NAND_SECTION[i])) break;
		//printf("\n%d",i);
		switch (i)
		{
		case 10:		//EXTCLK
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.fw_args.ext_clk = temp;				//set the data!!
			break;
		case 11:		//CPUSPEED
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.fw_args.cpu_speed = temp / Hand.fw_args.ext_clk;				//set the data!!
			break;
		case 12:		//PHMDIV
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.fw_args.phm_div = temp;				//set the data!!
			break;
		case 13:		//BOUDRATE
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.fw_args.boudrate = temp;				//set the data!!
			break;
		case 14:		//USEUART
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.fw_args.use_uart = temp;				//set the data!!
			break;
		default:;
		}
	}

	/* Load [SDRAM] section here */
	while(!strstr(line,"[NAND]"))
	{
		if (feof(fp))
		{
			printf("\n USBBoot.cfg is bad!");
			return -1;
		}
		fgets(line,100,fp);
		for (i=0;i<strlen(line);i++)
			if (line[i]==';') line[i]='\0';
		//printf("\n %s",line);
		for (i=0;i<NAND_SECTION_NUM;i++)
			if (strstr(line,NAND_SECTION[i])) break;
		//printf("\n%d",i);
		switch (i)
		{
		case 0:		//BUDWIDTH
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			if ( temp == 32 )
				Hand.fw_args.bus_width = 0;				//set the data!!
			else
				Hand.fw_args.bus_width = 1;				//set the data!!
			break;
		case 16:		//BANKNUM
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.fw_args.bank_num = temp / 4;				//set the data!!
			break;
		case 17:		//ROWADDR
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.fw_args.row_addr = temp;				//set the data!!
			break;
		case 18:		//COLADDR
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.fw_args.col_addr = temp;				//set the data!!
			break;
		case 19:		//ISMOBILE
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.fw_args.is_mobile = temp;				//set the data!!
			break;
		case 20:		//ISBUSSHARE
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.fw_args.is_busshare = temp;				//set the data!!
			break;
		default:;
		}
	}

	//Load [NAND] section here
	while(!strstr(line,"[END]"))
	{
		if (feof(fp))
		{
			printf("\n USBBoot.cfg is bad!");
			return -1;
		}
		fgets(line,100,fp);
		for (i=0;i<strlen(line);i++)
			if (line[i]==';') line[i]='\0';
		//printf("\n %s",line);
		for (i=0;i<NAND_SECTION_NUM;i++)
			if (strstr(line,NAND_SECTION[i])) break;
		//printf("\n%d",i);
		switch (i)
		{
		case 0:		//BUSWIDTH
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_bw=temp;				//set the data!!
			//printf("\n BUSWIDTH: %d",temp);
			break;
		case 1:		//ROWCYCLES
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_rc=temp;				//set the data!!
			//printf("\n ROWCYCLES: %d",temp);
			break;
		case 2:		//PAGESIZE
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_ps=temp;				//set the data!!
			//printf("\n PAGESIZE: %d",temp);
			break;
		case 3:		//PAGEPERBLOCK
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_ppb=temp;				//set the data!!
			//printf("\n PAGEPERBLOCK: %d",temp);
			break;
		case 4:		//FORCEERASE
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_force_erase=temp;				//set the data!!
			//printf("\n FORCEERASE: %d",temp);
			break;
	          /* we abandon PAGENUMBER after version 1.4a,replace by PLANENUM */
        case 5:		//PLANENUM
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_plane=temp;				//set the data!!
			//printf("\n PAGENUMBER: %d",temp);
			break;
		case 6:
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_os=temp;				//set the data!!
			//printf("\n OOBSIZE: %d",temp);
			break;
		case 7:											//ECCPOS
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_eccpos=temp;				//set the data!!
			//printf("\n ECCPOS: %d",temp);
			break; 
		case 8:											//"BADBLACKPOS",
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_bbpos=temp;				//set the data!!
			//printf("\n BBPOS: %d",temp);
			break;
		case 9:											//"BADBLACKPAGE",
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_bbpage=temp;				//set the data!!
			//printf("\n BBPAGE: %d",temp);
			break;
		case 21:											//"BCHBIT",
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_bchbit=temp;				//set the data!!
			//printf("\n BBPAGE: %d",temp);
			break;
		case 22:											//"WPPIN",
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_wppin=temp;				//set the data!!
			//printf("\n BBPAGE: %d",temp);
			break;
		case 23:											//"BLOCKPERCHIP",
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_bpc = temp;				//set the data!!
			//printf("\n BBPAGE: %d",temp);
			break;

		default:;
		}
	}
//	total_size = (unsigned int)(2 << (Hand.fw_args.row_addr + Hand.fw_args.col_addr - 1)) * 2 * (Hand.fw_args.bank_num + 1) * 2 * (2 - Hand.fw_args.bus_width);
	total_size = 0x801000000;
	fclose(fp);
	return 1;
}
 
void Init_Hand_Def(void)
{
	/* nand flash info */
//	Hand.nand_start=0;				//important !!!!
	Hand.pt = JZ4740;             //cpu type 
	Hand.nand_bw=8;
	Hand.nand_rc=3;
	Hand.nand_ps=2048;
	Hand.nand_ppb=64;
	Hand.nand_eccpos = 6;
	Hand.nand_bbpage = 0;
	Hand.nand_bbpos  = 0;
	Hand.nand_force_erase=0;
//	Hand.nand_ids=0;  /* vendor_id & device_id */
	Hand.fw_args.cpu_id = 0x4740;
	Hand.fw_args.ext_clk = 12;
	Hand.fw_args.cpu_speed = 336 / Hand.fw_args.ext_clk;
	Hand.fw_args.phm_div = 4;
	Hand.fw_args.use_uart = 0;
	Hand.fw_args.boudrate = 57600;
	Hand.fw_args.bus_width = 0;
	Hand.fw_args.bank_num = 1;
	Hand.fw_args.row_addr = 13;
	Hand.fw_args.col_addr = 9;
	Hand.fw_args.is_mobile = 0;
	Hand.fw_args.is_busshare = 1;
}

int Init_CFG(char *fname)
{
	ULONG nWritten,nRead;

	if (API_IsBoot() < 3)
	{
		printf("\n Device unboot! Boot it first!");
		return -1;
	}

	Read_Load_CFG(fname);

	if ( !Check_Dump_CFG() )
		return -1;

	WriteFile(hDevice, &Hand, sizeof(Hand), &nWritten, NULL);	//Send Hand_t data structure
	JZ4740_USB_CONFIGRATION(DS_hand,hDevice);			//Send VR request
	ReadFile(hDevice, ret, 8, &nRead, NULL);
	return 1;
}


int Handle_Stage1(char *fw,char *usbboot)
{
	FILE *fp;
	unsigned int flen,START_ADDR;
	ULONG nWriten;

	START_ADDR = total_size + 0x80000000;        //SDRAM in byte
	START_ADDR -= CODE_SIZE;                   //dynamic caculate start address
//	printf("START_ADDR %x %x \n",total_size,START_ADDR);
	if ((fp=fopen(fw,"rb"))==NULL)
	{
		printf("\n Can not open file :%s",fw);
		return -1;
	}
	//fread(code_buf,1,flen,fp);
	fseek(fp,0,SEEK_END);
	flen=ftell(fp);
	if (flen>16384)
	{
		printf("\n Cache file is too large!");
		return -1;
	}
	Hand.fw_args.debug_ops = 0;             //tell device it's not debug
	printf("\n Download stage one program and execute at 0x80002000: ");//,sizeof(fw_args_t));
	fseek(fp,0,SEEK_SET);
	fread(code_buf,1,flen,fp);
	memcpy( code_buf + 8, &Hand.fw_args, sizeof(fw_args_t) );           //write args to code
	JZ4740_USB_GET_CPU_INFO(hDevice);
	if (JZ4740_USB_SET_DATA_ADDRESS(0x80002000,hDevice)!=1) return -1;
	WriteFile(hDevice, code_buf, flen, &nWriten, NULL);			//write code_1
	if (JZ4740_USB_PROG_START1(0x80002000,hDevice)!=1) return -1;	//execute code_1 ,init SDRAM
	//wait_delay = 0x7fffff;
	//while(wait_delay--);											//wait for return
	Sleep(100);
	JZ4740_USB_GET_CPU_INFO(hDevice);
	fclose(fp);
	printf("Pass");
#if 1
	if ((fp=fopen(usbboot,"rb"))==NULL)
	{
		printf("\n Can not open file :%s",usbboot);
		return -1;
	}
	//fread(code_buf,1,flen,fp);
	printf("\n Download stage two program and execute at 0x%8x: ",START_ADDR);
	fseek(fp,0,SEEK_END);
	flen=ftell(fp);
	fseek(fp,0,SEEK_SET);
	fread(code_buf,1,flen,fp);
	memcpy( code_buf + 8, &Hand.fw_args, sizeof(fw_args_t) );          //write args to code
	if (JZ4740_USB_SET_DATA_ADDRESS(START_ADDR,hDevice)!=1) return -1;	//it is ucos
	WriteFile(hDevice, code_buf, flen, &nWriten, NULL);			//write code_1
	JZ4740_USB_GET_CPU_INFO(hDevice);
	JZ4740_USB_FLUSH_CACHES(hDevice);
	if (JZ4740_USB_PROG_START2(START_ADDR,hDevice)!=1) return -1;				//execute code_2 ,now we can do usbboot!
	JZ4740_USB_GET_CPU_INFO(hDevice);
	fclose(fp);
	printf("Pass");
#endif
	return 1;
} 

int API_Debug_Memory(int obj, unsigned int start, unsigned int size)
{
	FILE *fp;
	unsigned int flen,buffer[4],tmp;
	ULONG nWriten;

	if (Handle_Open(obj)==-1)
	{
		printf("\n Can not connect device!");
		return -1;
	}

	tmp = API_IsBoot();
	if (tmp > 2)
	{
		printf("\n This command only run under UNBOOT state!");
		return -1;
	}
	switch ( tmp )
	{
	case 1:            //Jz4740v1
		tmp = 0;
		Hand.fw_args.cpu_id = 0x4740;
		break;
	case 2:            //Jz4750v1
		tmp = 0;
		Hand.fw_args.cpu_id = 0x4750;
		break;
	}

	if ((fp=fopen("fw.bin","rb"))==NULL)
	{
		printf("\n Can not open file fw.bin");
		return -1;
	}
	fseek(fp,0,SEEK_END);
	flen=ftell(fp);
	if (flen>16384)
	{
		printf("\n Cache file is too large!");
		return -1;
	}
	Hand.fw_args.debug_ops = 1;             //tell device it's memory debug
	Hand.fw_args.start = start;
	if (size == 0)
		Hand.fw_args.size = total_size;
	else
		Hand.fw_args.size = size;
	printf("\n Now test memory from %x to %x: ",start, start + Hand.fw_args.size);
	fseek(fp,0,SEEK_SET);
	fread(code_buf,1,flen,fp);
	memcpy( code_buf + 8, &Hand.fw_args, sizeof(fw_args_t) );           //write args to code
	JZ4740_USB_GET_CPU_INFO(hDevice);
	if (JZ4740_USB_SET_DATA_ADDRESS(0x80002000,hDevice)!=1) return -1;
	WriteFile(hDevice, code_buf, flen, &nWriten, NULL);			//write code_1
	if (JZ4740_USB_PROG_START1(0x80002000,hDevice)!=1) return -1;	//execute code_1 ,init SDRAM
	ReadFile(hDevice, buffer, 8, &nRead, NULL);
	//JZ4740_USB_GET_CPU_INFO(hDevice);
	if (buffer[0] != 0)
		printf("\n Test memory fail! Last error address is %x !",buffer[0]);
	else
		printf("\n Test memory pass!");
	return 0;
}

int API_Debug_GPIO(int obj, unsigned char ops, unsigned char pin)
{
	FILE *fp;
	unsigned int flen,tmp;
	ULONG nWriten;

	if (Handle_Open(obj)==-1)
	{
		printf("\n Can not connect device!");
		return -1;
	}

	tmp = API_IsBoot();
	if (tmp > 2)
	{
		printf("\n This command only run under UNBOOT state!");
		return -1;
	}
	switch ( tmp )
	{
	case 1:            //Jz4740v1
		tmp = 0;
		Hand.fw_args.cpu_id = 0x4740;
		if (pin > 124) 
		{
			printf("\n Jz4740 has 124 GPIO pin in all!");
			return -1;
		}
		break;
	case 2:            //Jz4750v1
		tmp = 0;
		Hand.fw_args.cpu_id = 0x4750;
		if (pin > 178) 
		{
			printf("\n Jz4750 has 178 GPIO pin in all!");
			return -1;
		}

		break;
	}

	if ((fp=fopen("fw.bin","rb"))==NULL)
	{
		printf("\n Can not open file fw.bin");
		return -1;
	}
	fseek(fp,0,SEEK_END);
	flen=ftell(fp);
	if (flen>16384)
	{
		printf("\n Cache file is too large!");
		return -1;
	}
	Hand.fw_args.debug_ops = ops;             //tell device it's memory debug
	Hand.fw_args.pin_num = pin;
	if (ops == 2)
		printf("\n GPIO %d set!",pin);
	else
		printf("\n GPIO %d clear!",pin);

	fseek(fp,0,SEEK_SET);
	fread(code_buf,1,flen,fp);
	memcpy( code_buf + 8, &Hand.fw_args, sizeof(fw_args_t) );           //write args to code
	JZ4740_USB_GET_CPU_INFO(hDevice);
	if (JZ4740_USB_SET_DATA_ADDRESS(0x80002000,hDevice)!=1) return -1;
	WriteFile(hDevice, code_buf, flen, &nWriten, NULL);			//write code_1
	if (JZ4740_USB_PROG_START1(0x80002000,hDevice)!=1) return -1;	//execute code_1 ,init SDRAM
	JZ4740_USB_GET_CPU_INFO(hDevice);
	return 0;
}

int API_Init()
{
	Init_Hand_Def();
	Read_Load_CFG("USBBoot.cfg");
	return 1;
}

int API_IsBoot(void)
{
	return JZ4740_USB_GET_CPU_INFO(hDevice);
}

int API_Get_Dev_Num()		//：获取当前已经连接的设备个数
{
	int i,j=0;
	for (i=0;i<MAX_DEV_NUM;i++)
		if ((hDevice=OpenByInterface(&ClassGuid, i, &Error))!=INVALID_HANDLE_VALUE)
		{
			j++;
			Handle_Close();
		}

	return j;
}

//操作类API:
int API_Boot(int obj)				//：对选中的设备进行Boot操作
{
	int tmp;

	if (Handle_Open(obj)==-1)
	{
		printf(" Boot fail!");
		printf("\n Can not connect device!");
		return -1;
	}

	Read_Load_CFG("USBBoot.cfg");

	printf("\n Checking state of No.%d device: ",obj);
#if 1
		tmp = API_IsBoot();
		switch ( tmp )
		{
		case 1:            //Jz4740v1
			tmp = 0;
			Hand.fw_args.cpu_id = 0x4740;
			break;
		case 2:            //Jz4750v1
			tmp = 0;
			Hand.fw_args.cpu_id = 0x4750;
			break;
		case 3:            //Boot4740
			tmp = 1;
			Hand.fw_args.cpu_id = 0x4740;
			break;
		case 4:            //Boot4750
			tmp = 1;
			Hand.fw_args.cpu_id = 0x4750;
			break;
		}

		if ( tmp )
		{
			printf("Booted");
//			return -1;
		}
		else 
		{
			printf("Unboot");
			printf("\n Now booting No.%d device: ",obj);
			if (Handle_Stage1("fw.bin","usb_boot.bin")==-1)
			{
				printf("\n Boot fail");
				return -1;
			}		
			else printf("\n Boot success!");
		}
//		Handle_Close();
		Sleep(100);		
#endif
		printf("\n Now configure No.%d device: ",obj);
		if (Init_CFG("USBBoot.cfg")==1)
			printf("\n Configure success!");
		else printf("\n Configure fail!");
		Handle_Close();
	return 1;
}

int API_Fconfig(int obj,char *fname)	//：用fname指定的配置文件对设备进行配置
{
	printf("\n Configing No.%d device: ",obj);
		if (Handle_Open(obj)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}
		if (!Read_Load_CFG(fname))
		{
			printf(" Init CFG fail!");
			return -1;
		}

		WriteFile(hDevice, &Hand, sizeof(Hand), &nWritten, NULL);	//Send Hand_t data structure
		JZ4740_USB_CONFIGRATION(DS_hand,hDevice);			//Send VR request
		ReadFile(hDevice, ret, 8, &nRead, NULL);
		printf("\n Init Configration success!");
		Handle_Close();
	return 1;
}

int API_Go(int obj,unsigned int addr)			//：从RAM中的addr地址开始运行程序
{
		printf("\n Executing No.%d device at address %x !",obj,addr);
		if (Handle_Open(obj)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}
		JZ4740_USB_PROG_START2(addr,hDevice);
		Handle_Close();
	
	return 1;
}

int API_SD_Program_File(NAND_IN *nand_in,NAND_OUT *nand_out,char *fname)
{
	int i,flen,m,j,k;
	unsigned int start_page=0,page_num,code_len,offset,transfer_size;
	FILE *fp;
	unsigned char status_buf[32];
	NAND_IN n_in;
	NAND_OUT n_out;

		fp=fopen(fname,"rb");
		if (fp==NULL)
		{
			printf("\n Can not open file !");
			return 0;
		}
		printf("\n Programing No.%d device...",nand_in->dev);
		fseek(fp,0,SEEK_END);
		flen=ftell(fp);
		nand_in->start;
		n_in.length = flen / 512;

		transfer_size = 512 * 1024;

		m = flen / transfer_size;
		j = flen % transfer_size;
		fseek(fp,0,SEEK_SET);		//file point return to begin
		offset = 0; 
		printf("\n Total size to send in byte is :%d",flen);
		printf("\n It will cause %d times buffer transfer.",m+1);

		for (k=0;k<m;k++)
		{
			page_num = transfer_size / 512;

			fread(code_buf,1,transfer_size,fp);			//read code from file to buffer
			printf("\n No.%d Programming...",k+1);
			nand_in->length = transfer_size;               //code length,not page number!
			nand_in->buf = code_buf;
			start_page = API_SD_Program_Check(nand_in,&n_out);
			nand_in->start += page_num;
			offset += transfer_size ;
			fseek(fp,offset,SEEK_SET);
		}

		if (j)
		{
			if (j % 512 != 0)
				j = (j / 512 + 1) * 512;

			memset(code_buf,0,j);				//set all to null
			fread(code_buf,1,j,fp);						//read code from file to buffer
			nand_in->length = j;
			nand_in->buf = code_buf;
			printf("\n No.%d Programming...",k+1);
			API_SD_Program_Check(nand_in,&n_out);
		}
	
		fclose(fp);

	return 1;
}


int API_Nand_Program_File(NAND_IN *nand_in,NAND_OUT *nand_out,char *fname)
{
	int i,flen,m,j,k;
	unsigned int start_page=0,page_num,code_len,offset,transfer_size;
	FILE *fp;
	unsigned char status_buf[32];
	NAND_IN n_in;
	NAND_OUT n_out;

#if 0
//	nand_out->status = (unsigned char *)malloc(nand_in->max_chip * sizeof(unsigned char));
	nand_out->status = status_buf;
	for (i=0;i<nand_in->max_chip;i++)
		(nand_out->status)[i] = 0;								//set all status to fail
#endif
		fp=fopen(fname,"rb");
		if (fp==NULL)
		{
			printf("\n Can not open file !");
			return 0;
		}
		printf("\n Programing No.%d device...",nand_in->dev);
		fseek(fp,0,SEEK_END);
		flen=ftell(fp);
		n_in.start = nand_in->start /Hand.nand_ppb; 
		if (nand_in->option == NO_OOB)
		{
			if ( flen % ( Hand.nand_ppb * Hand.nand_ps ) == 0 ) 
				n_in.length = flen / ( Hand.nand_ps * Hand.nand_ppb );
			else
				n_in.length = flen / ( Hand.nand_ps * Hand.nand_ppb ) + 1;
		}
		else 
		{
			if ( flen % ( Hand.nand_ppb * (Hand.nand_ps + Hand.nand_os)) == 0 ) 
				n_in.length = flen / ( (Hand.nand_ps + Hand.nand_os) * Hand.nand_ppb );
			else
				n_in.length = flen / ( (Hand.nand_ps + Hand.nand_os) * Hand.nand_ppb ) + 1;
		}
		//printf(" length %d flen %d \n",n_in.length,flen);
		n_in.cs_map = nand_in->cs_map;
		n_in.dev = nand_in->dev;
		n_in.max_chip = nand_in->max_chip;
		if (API_Nand_Erase(&n_in)!=1) return -1;

		if (nand_in->option == NO_OOB)
			transfer_size = (Hand.nand_ppb *  Hand.nand_ps);
		else
			transfer_size = (Hand.nand_ppb * ( Hand.nand_ps + Hand.nand_os ));
		m = flen / transfer_size;
		j = flen % transfer_size;
		fseek(fp,0,SEEK_SET);		//file point return to begin
		offset = 0; 
		printf("\n Total size to send in byte is :%d",flen);
		printf("\n Image type : %s",IMAGE_TYPE[nand_in->option]);
		printf("\n It will cause %d times buffer transfer.",m+1);
#if 0
		for (i=0;i<nand_in->max_chip;i++)
			(nand_out->status)[i] = 1;								//set all status to success!
#endif
		for (k=0;k<m;k++)
		{
			if (nand_in->option == NO_OOB)
			{
				page_num = transfer_size / Hand.nand_ps;
			}else
			{
				page_num = transfer_size / (Hand.nand_ps + Hand.nand_os);
			}
			code_len = transfer_size;
			fread(code_buf,1,code_len,fp);			//read code from file to buffer
			printf("\n No.%d Programming...",k+1);
			nand_in->length = code_len;               //code length,not page number!
			nand_in->buf = code_buf;
			start_page = API_Nand_Program_Check(nand_in,&n_out);
			if ( start_page - nand_in->start > Hand.nand_ppb ) 
				printf("\n Skip a old bad block !");
			nand_in->start = start_page;
#if 0
			for (i=0;i<nand_in->max_chip;i++)
			{
				(nand_out->status)[i] = (nand_out->status)[i] * (n_out.status)[i];
			}
#endif
			//offset += code_len - 1;
			offset += code_len ;
			//start_page += page_num;
//			nand_in->start += page_num;
			fseek(fp,offset,SEEK_SET);
		}

		if (j)
		{
			if (nand_in->option == NO_OOB)
			{
				if (j % Hand.nand_ps != 0)
					j = (j / Hand.nand_ps + 1) * Hand.nand_ps;
			}
			else
			{
				if (j % (Hand.nand_ps + Hand.nand_os) != 0)
					j = (j / (Hand.nand_ps + Hand.nand_os) + 1) * (Hand.nand_ps + Hand.nand_os);
			}

			memset(code_buf,0,j);				//set all to null
			fread(code_buf,1,j,fp);						//read code from file to buffer
			nand_in->length = j;
			nand_in->buf = code_buf;
			printf("\n No.%d Programming...",k+1);
			start_page = API_Nand_Program_Check(nand_in,&n_out);
			if ( start_page - nand_in->start > Hand.nand_ppb ) 
				printf(" Skip a old bad block !");
#if 0
			for (i=0;i<nand_in->max_chip;i++)
			{
				(nand_out->status)[i] = (nand_out->status)[i] * (n_out.status)[i];
 			}
#endif
		}
	
		fclose(fp);
	//}
	return 1;
}

int API_Nand_Program_File_Planes(NAND_IN *nand_in,NAND_OUT *nand_out,char *fname)
{
	int i,flen,m,j,k,l;
	unsigned int start_page=0,page_num,code_len,offset,transfer_size,buf_off,tmp_off;
	unsigned char *tmp_buf, status_buf[32];
	FILE *fp;

	NAND_IN n_in;
	NAND_OUT n_out;
#if 0
//	nand_out->status = (unsigned char *)malloc(nand_in->max_chip * sizeof(unsigned char));
	nand_out->status = status_buf;
	for (i=0;i<nand_in->max_chip;i++)
		(nand_out->status)[i] = 0;								//set all status to fail
#endif
		fp=fopen(fname,"rb");
		if (fp==NULL)
		{
			printf("\n Can not open file !");
			return 0;
		}
//		printf("\n Programing No.%d device...",nand_in->dev);
		fseek(fp,0,SEEK_END);
		flen=ftell(fp);
		n_in.start = nand_in->start /Hand.nand_ppb; 
		if (nand_in->option == NO_OOB)
		{
			if ( flen % ( Hand.nand_ppb * Hand.nand_ps ) == 0 ) 
				n_in.length = flen / ( Hand.nand_ps * Hand.nand_ppb );
			else
//				n_in.length = flen / ( Hand.nand_ps * Hand.nand_ppb ) + 1;
				n_in.length = flen / ( Hand.nand_ps * Hand.nand_ppb ) + Hand.nand_plane;
		}
		else 
		{
			if ( flen % ( Hand.nand_ppb * Hand.nand_ps ) == 0 ) 
				n_in.length = flen / ( (Hand.nand_ps + Hand.nand_os) * Hand.nand_ppb );
			else
//				n_in.length = flen / ( (Hand.nand_ps + Hand.nand_os) * Hand.nand_ppb ) + 1;
				n_in.length = flen / ( (Hand.nand_ps + Hand.nand_os) * Hand.nand_ppb ) + Hand.nand_plane;
		}
		printf(" length %d flen %d \n",n_in.length,flen);
		n_in.cs_map = nand_in->cs_map;
		n_in.dev = nand_in->dev;
		n_in.max_chip = nand_in->max_chip;
		if (API_Nand_Erase(&n_in)!=1) return -1;

		if (nand_in->option == NO_OOB)
			transfer_size = (Hand.nand_ppb *  Hand.nand_ps);
		else
			transfer_size = (Hand.nand_ppb * ( Hand.nand_ps + Hand.nand_os ));
		m = flen / transfer_size / Hand.nand_plane;
		j = flen % (transfer_size * Hand.nand_plane);
		fseek(fp,0,SEEK_SET);		//file point return to begin
		offset = 0;
		printf("\n Total size to send in byte is :%d",flen);
		printf("\n Image type : %s",IMAGE_TYPE[nand_in->option]);
		printf("\n It will cause %d times buffer transfer.",m+1);
#if 0
		for (i=0;i<nand_in->max_chip;i++)
			(nand_out->status)[i] = 1;								//set all status to success!
#endif
		tmp_buf = (unsigned char *)malloc(1024 * 1024 * 2);
		for (k=0;k<m;k++)
		{
			code_len = transfer_size * Hand.nand_plane;
			fread(tmp_buf,1,code_len,fp);			//read code from file to buffer
retry:
			for (l = 0; l < Hand.nand_plane; l ++)
			{
				buf_off = 0;
				tmp_off = 0;
				for (i = 0; i < Hand.nand_ppb; i ++)
				{
					//printf("ddddddddd%d\n",i);
					memcpy(code_buf + buf_off, tmp_buf + tmp_off + l * Hand.nand_ps, Hand.nand_ps);
					buf_off += Hand.nand_ps;
					tmp_off += (Hand.nand_ps * Hand.nand_plane);
					if (nand_in->option != NO_OOB)
					{
						memcpy(code_buf + buf_off, tmp_buf + tmp_off + l * Hand.nand_os, Hand.nand_os);
						buf_off += Hand.nand_os;
						tmp_off += (Hand.nand_os * Hand.nand_plane);
					}
				}
				printf("\n No.%d Programming...",k+1);
				nand_in->length = transfer_size;               //code length,not page number!
				nand_in->buf = code_buf;
				start_page = API_Nand_Program_Check(nand_in,&n_out);
				if ( start_page - nand_in->start > Hand.nand_ppb ) 
				{
					nand_in->start = ((start_page - Hand.nand_ppb) / (Hand.nand_ppb * Hand.nand_plane)) * (Hand.nand_ppb * Hand.nand_plane) + (Hand.nand_ppb * Hand.nand_plane);
					printf("\n Skip %d old bad block and sync to %d page!",Hand.nand_plane, nand_in->start);
					goto retry;
				}
				nand_in->start = start_page;
			}
#if 0
			for (i=0;i<nand_in->max_chip;i++)
			{
				(nand_out->status)[i] = (nand_out->status)[i] * (n_out.status)[i];
			}
#endif
			//offset += code_len - 1;
			offset += code_len ;
			//start_page += page_num;
//			nand_in->start += page_num;
			fseek(fp,offset,SEEK_SET);
		}

		if (j)
		{
			if (nand_in->option == NO_OOB)
			{
//				j += Hand.nand_ps - (j%Hand.nand_ps);
				page_num = j / Hand.nand_ps / Hand.nand_plane;
				if (j % (Hand.nand_ps * Hand.nand_plane)!= 0) page_num ++;
				j = page_num * Hand.nand_ps * Hand.nand_plane;
			}
			else
			{
//				j += (Hand.nand_ps + Hand.nand_os) - (j % (Hand.nand_ps + Hand.nand_os));
				page_num = j / (Hand.nand_ps + Hand.nand_os) / Hand.nand_plane;
				if (j % ((Hand.nand_ps + Hand.nand_os) * Hand.nand_plane) != 0) page_num ++;
				j = page_num * (Hand.nand_ps + Hand.nand_os) * Hand.nand_plane;
			}
			//printf("debug %d %d \n",j, page_num);
			memset(code_buf,0xff,j);				//set all to null
			fread(tmp_buf,1,j,fp);						//read code from file to buffer
retry1:
			for (l = 0; l < Hand.nand_plane; l ++)
			{
				buf_off = 0;
				tmp_off = 0;
				for (i = 0; i < page_num; i ++)
				{
//					printf("debug %d %d\n", buf_off, tmp_off);
					memcpy(code_buf + buf_off, tmp_buf + tmp_off + l * Hand.nand_ps, Hand.nand_ps);
					buf_off += Hand.nand_ps;
					tmp_off += (Hand.nand_ps * Hand.nand_plane);
					if (nand_in->option != NO_OOB)
					{
						memcpy(code_buf + buf_off, tmp_buf + tmp_off + l * Hand.nand_os, Hand.nand_os);
						buf_off += Hand.nand_os;
						tmp_off += (Hand.nand_os * Hand.nand_plane);
					}
				}

				nand_in->length = j / Hand.nand_plane;
				nand_in->buf = code_buf;
				printf("\n No.%d Programming...",k+1);
				start_page = API_Nand_Program_Check(nand_in,&n_out);
				if ( start_page - nand_in->start > Hand.nand_ppb ) 
				{
					nand_in->start = ((start_page - Hand.nand_ppb) / (Hand.nand_ppb * Hand.nand_plane)) * (Hand.nand_ppb * Hand.nand_plane) + (Hand.nand_ppb * Hand.nand_plane);
					printf("\n Skip %d old bad block and sync to %d page!",Hand.nand_plane, nand_in->start);
					goto retry1;
				}
#if 0
				for (i=0;i<nand_in->max_chip;i++)
				{
					(nand_out->status)[i] = (nand_out->status)[i] * (n_out.status)[i];
 				}
#endif
				nand_in->start = (start_page + Hand.nand_ppb - (start_page % Hand.nand_ppb));
			}
		}
	
		fclose(fp);
		free(tmp_buf);
	//}
	return 1;
}

int API_Nand_Read(NAND_IN *nand_in,char *fname)
{
	unsigned int i,j;
	unsigned int start_addr = nand_in->start,length = nand_in->length,page_num;
	unsigned char csn;
	unsigned short temp;

		if (Handle_Open(nand_in->dev)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}

		if (start_addr > NAND_MAX_PAGE_NUM || length > NAND_MAX_PAGE_NUM )
		{
			printf("\n Page number overflow!");
			return -1;
		}
		if (API_IsBoot() < 3)
		{
			printf("\n Device unboot! Boot it first!");
			return -1;
		}
		for (i=0;i<nand_in->max_chip;i++) 
			if ((nand_in->cs_map)[i]!=0) break;
		if (i>=nand_in->max_chip) return 1;
		csn = i;
		//memset(nand_in->buf,0,page_num * Hand.nand_ps);
		printf("\n Reading from No.%d device No.%d flash....",nand_in->dev,csn);

		page_num = length / Hand.nand_ps +1;
		JZ4740_USB_SET_DATA_ADDRESS(start_addr,hDevice);
		JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
		temp = ((NO_OOB<<12) & 0xf000) + ((csn<<4) & 0xff0) + NAND_READ;
		//printf("\n temp %x",temp);
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, nand_in->buf, page_num * Hand.nand_ps, &nRead, NULL);
		ReadFile(hDevice, ret, 8, &nRead, NULL);
		//printf("read to %d \n",(ret[3]<<24)|(ret[2]<<16)|(ret[1]<<8)|(ret[0]<<0));

		for (j=0;j<length;j++) 
		{
			if (j % 16==0) printf("\n 0x%08x :",j);
			printf("%02x ",(nand_in->buf)[j]);
		}

//		printf("\n Operation status: Success!");
		printf("\n Operation end position : %d ",(ret[3]<<24)|(ret[2]<<16)|(ret[1]<<8)|(ret[0]<<0));
		Handle_Close();

	return 1;
}

int API_SD_Read(NAND_IN *nand_in,char *fname)
{
	unsigned int i,j;
	unsigned int start_addr = nand_in->start,length = nand_in->length,page_num;
	unsigned char csn;
	unsigned short temp;
	FILE *fp = 0;

		if (Handle_Open(nand_in->dev)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}

		if (API_IsBoot() < 3)
		{
			printf("\n Device unboot! Boot it first!");
			return -1;
		}
		csn = i;

		if (fname)
		{
			fp = fopen(fname, "wb+");
			if (!fp)
			{
				printf("\n Can not open file: %s",fname);
				return -1;
			}
		}
		else
			fp = 0;

		printf("\n Reading from No.%d device No.%d flash....",nand_in->dev,csn);

		for (i = 0; i < length; i ++)
		{
			JZ4740_USB_SET_DATA_ADDRESS(start_addr,hDevice);
			JZ4740_USB_SET_DATA_LENGTH(1,hDevice);
			temp = ((NO_OOB<<12) & 0xf000) + ((csn<<4) & 0xff0) + SD_READ;
 			start_addr ++;

			JZ4740_USB_NAND_OPS(temp,hDevice);
			ReadFile(hDevice, nand_in->buf, 512, &nRead, NULL);

			if (!fp)
			{
				for (j=0;j<512;j++) 
				{
					if (j % 16==0) printf("\n 0x%08x :",j);
					printf("%02x ",(nand_in->buf)[j]);
				}
			}
			else
			{
				if (i % 60 == 0) printf("\n");
				printf("#");
				fwrite(nand_in->buf, 1, 512, fp);
			}
		}

		if (fp)	fclose(fp);
		Handle_Close();

	return 1;
}

int API_Nand_Readoob(NAND_IN *nand_in,char *fname)
{
	unsigned int i,j;
	unsigned char csn;
	unsigned int start_addr = nand_in->start ,length = nand_in->length,page_num;
	ULONG	nRead;

		if (Handle_Open(nand_in->dev)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}

		if (start_addr > NAND_MAX_PAGE_NUM || length> NAND_MAX_PAGE_NUM )
		{
			printf("\n Page number overflow!");
			return -1;
		}
		if (API_IsBoot() < 3)
		{
			printf("\n Device unboot! Boot it first!");
			return -1;
		}
		for (i=0;i<nand_in->max_chip;i++) 
			if ((nand_in->cs_map)[i]!=0) break;
		if (i>=nand_in->max_chip) return 1;
		csn = i;
		//memset(nand_in->buf,0,(length/Hand.nand_ps+1) * Hand.nand_ps);
		printf("\n Reading OOB from No.%d device No.%d flash....",nand_in->dev,csn);

		page_num = length/Hand.nand_ps+1;
		JZ4740_USB_SET_DATA_ADDRESS(start_addr,hDevice);
		JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
		unsigned short temp = ((csn<<4) & 0xff0) + NAND_READ_OOB;
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, nand_in->buf, page_num * Hand.nand_ps, &nRead, NULL);

		ReadFile(hDevice, ret, 8, &nRead, NULL);
		//printf("oob read to %d \n",(ret[3]<<24)|(ret[2]<<16)|(ret[1]<<8)|(ret[0]<<0));

		for (j=0;j<length;j++) 
		{
			if (j % 16==0) printf("\n 0x%08x :",j);
			printf("%02x ",(nand_in->buf)[j]);
		}

		//printf("\n Operation status: Success!");
		printf("\n Operation end position : %d ",(ret[3]<<24)|(ret[2]<<16)|(ret[1]<<8)|(ret[0]<<0));
		Handle_Close();
	
	return 1;
}

int API_Nand_Readraw(NAND_IN *nand_in,char *fname)
{
	unsigned int i,j;
	unsigned int start_addr = nand_in->start ,length = nand_in->length ,page_num;
	unsigned char csn;
	unsigned short temp;
	FILE *fp;

		if (Handle_Open(nand_in->dev)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}

		if (start_addr > NAND_MAX_PAGE_NUM || length> NAND_MAX_PAGE_NUM )
		{
			printf("\n Page number overflow!");
			return -1;
		}
		if (API_IsBoot() < 3)
		{
			printf("\n Device unboot! Boot it first!");
			return -1;
		}
		for (i=0;i<nand_in->max_chip;i++) 
			if ((nand_in->cs_map)[i]!=0) break;
		if (i>=nand_in->max_chip) return 1;
		csn = i;
		//memset(nand_in->buf,0,(length/Hand.nand_ps+1) * Hand.nand_ps);
		printf("\n Reading RAW from No.%d device No.%d flash....",nand_in->dev,csn);
		page_num = length/Hand.nand_ps +1;

		JZ4740_USB_SET_DATA_ADDRESS(start_addr,hDevice);
		JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
		temp = ((NO_OOB<<12) & 0xf000) + ((csn<<4) & 0xff0) + NAND_READ_RAW;
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, nand_in->buf, page_num * Hand.nand_ps, &nRead, NULL);
		ReadFile(hDevice, ret, 8, &nRead, NULL);
#if 1
		fp = fopen("dump.bin","wb+");	
		fwrite(nand_in->buf, 1, length, fp);
		fclose(fp);

//#else
		for (j=0;j<length;j++) 
		{
			if (j % 16==0) printf("\n 0x%08x :",j);
			printf("%02x ",(nand_in->buf)[j]);
		}
#endif


		//printf("\n Operation status: Success!");
		printf("\n Operation end position : %d ",(ret[3]<<24)|(ret[2]<<16)|(ret[1]<<8)|(ret[0]<<0));
		Handle_Close();
	
	return 1;
}

int API_Nand_Erase(NAND_IN *nand_in)
{
	unsigned int start_blk,blk_num,end_block;
	int i;

	start_blk = nand_in->start;
	blk_num = nand_in->length;
		if (start_blk > (unsigned int)NAND_MAX_BLK_NUM) 
		{
			printf("\n Start block number overflow!");
			return -1;
		}
		if (blk_num > (unsigned int)NAND_MAX_BLK_NUM)
		{
			printf("\n Length block number overflow!");
			return -1;
		}
	if (Handle_Open(nand_in->dev)==-1)
	{
		printf("\n Can not connect device!");
		return -1;
	}
	if (API_IsBoot() < 3)
	{
		printf("\n Device unboot! Boot it first!");
		return -1;
	}

	for (i=0;i<nand_in->max_chip;i++)
	{
		if ((nand_in->cs_map)[i]==0) continue;
		printf("\n Erasing No.%d device No.%d flash......",nand_in->dev,i);

		JZ4740_USB_SET_DATA_ADDRESS(start_blk,hDevice);
		JZ4740_USB_SET_DATA_LENGTH(blk_num,hDevice);
		unsigned short temp = ((i<<4) & 0xff0) + NAND_ERASE;
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, ret, 8, &nRead, NULL);
		printf(" Finish!");
	}
	Handle_Close();
	end_block = ((ret[3]<<24)|(ret[2]<<16)|(ret[1]<<8)|(ret[0]<<0)) / Hand.nand_ppb;
	printf("\n Operation end position : %d ",end_block);
	if ( !Hand.nand_force_erase )     //not force erase ,show bad block infomation
	{
		printf("\n There are marked bad blocks :%d ",end_block - start_blk - blk_num );
	}
	else                              //force erase ,no bad block infomation can show
	{
		printf("\n Force erase ,no bad block infomation !" );
	}
	return 1;
}

#if 0
static int Nand_Check(unsigned char *id)
{
	int writesize, erasesize, oobsize;
	writesize = (1024 << (id[3] & 0x3);
	id[3] >>= 2;
	oobsize = (8 << (id[3] & 0x01)) * (writesize >> 9);
	id[3] >>= 2;
	erasesize = (64 * 1024) << (id[3] & 0x03);

	if (Hand.nand_ps != writesize)
	{
		printf("\n PAGESIZE setting error! ");
		return -1;
	}
	if (Hand.nand_os != oobsize)
	{
		printf("\n OOBSIZE setting error! ");
		return -1;
	}
	if (Hand.nand_ppb != erasesize / writesize)
	{
		printf("\n PAGEPERBLOCK setting error! ");
		return -1;
	}

	if (id[4] == 0x0 || id[4] == 0xff)
		Hand.nand_bpc = 0x10000000;
	else
	{
	}

	return 1;
}
#endif

int API_Nand_Query(NAND_IN * nand_in)
{
	int i;
	unsigned char csn;

		if (Handle_Open(nand_in->dev)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}
		if (API_IsBoot() < 3)
		{
			printf("\n Device unboot! Boot it first!");
			return -1;
		}
		for (i=0;i<nand_in->max_chip;i++) 
			if ((nand_in->cs_map)[i]!=0) break;
		if (i>=nand_in->max_chip) return 1;
		csn = i;
		printf("\n ID of No.%d device No.%d flash: ",nand_in->dev,csn);
		unsigned short temp = ((csn<<4) & 0xff0) + NAND_QUERY;
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, ret, 8, &nRead, NULL);
		printf("\n Vendor ID    :0x%x ",(unsigned char)ret[0]);
		printf("\n Product ID   :0x%x ",(unsigned char)ret[1]);
		printf("\n Chip ID      :0x%x ",(unsigned char)ret[2]);
		printf("\n Page ID      :0x%x ",(unsigned char)ret[3]);
		printf("\n Plane ID     :0x%x ",(unsigned char)ret[4]);
		ReadFile(hDevice, ret, 8, &nRead, NULL);
		printf("\n Operation status: Success!");
		Handle_Close();

	return 1;
}

int API_Nand_Markbad(NAND_IN *nand_in)
{
	if (Handle_Open(nand_in->dev)==-1)
	{
		printf("\n Can not connect device!");
		return -1;
	}
	if (API_IsBoot() < 3)
	{
		printf("\n Device unboot! Boot it first!");
		return -1;
	}
	//printf("mark bad block : %d \n",nand_in->start);
	JZ4740_USB_SET_DATA_ADDRESS(nand_in->start,hDevice);
	JZ4740_USB_NAND_OPS(NAND_MARK_BAD,hDevice);
	ReadFile(hDevice, ret, 8, &nRead, NULL);
	printf("\n Mark bad block at %d ",((ret[3]<<24)|(ret[2]<<16)|(ret[1]<<8)|(ret[0]<<0))/Hand.nand_ppb);
	Handle_Close();
	return 0;
}

int API_Nand_Program_Check(NAND_IN *nand_in,NAND_OUT *nand_out)
{
	unsigned int i,page_num,cur_page;
	unsigned short temp;
	unsigned char status_buf[32];

	if (nand_in->length > (unsigned int)MAX_TRANSFER_SIZE)
	{
		printf("\n Buffer size too long!");
		return -1;
	}

#if 0
	//nand_out->status = (unsigned char *)malloc(nand_in->max_chip * sizeof(unsigned char));
	nand_out->status = status_buf;

	for (i=0;i<nand_in->max_chip;i++)
		(nand_out->status)[i] = 0;								//set all status to fail
#endif

	if (Handle_Open(nand_in->dev)==-1)
	{
		printf("\n Can not connect device!");
		return -1;
	}
	if (API_IsBoot() < 3)
	{
		printf("\n Device unboot! Boot it first!");
		return -1;
	}
	WriteFile(hDevice, nand_in->buf, nand_in->length , &nWritten, NULL);
	//dump_data(nand_in->buf, 100);
	//WriteFile(hDevice, nand_in->buf, nand_in->length * Hand.nand_ps, &nWritten, NULL);			//Send data to be program
																				//Only send once!
	for (i=0;i<nand_in->max_chip;i++)
	{
		if ((nand_in->cs_map)[i]==0) continue;

			//page_num = nand_in->length / Hand.nand_ps +1;
			if (nand_in->option == NO_OOB) 
			{
				page_num = nand_in->length / Hand.nand_ps;
				if ((nand_in->length%Hand.nand_ps) !=0) page_num++;
				//temp = ((i<<4) & 0xff0) + NAND_PROGRAM;
			}
			else 
			{
				page_num = nand_in->length / (Hand.nand_ps + Hand.nand_os);
				if ((nand_in->length% (Hand.nand_ps + Hand.nand_os)) !=0) page_num++;
				//temp = ((i<<4) & 0xff0) + NAND_PROGRAM_OOB;
			}
			temp = ((nand_in->option<<12) & 0xf000)  + ((i<<4) & 0xff0) + NAND_PROGRAM;	
			JZ4740_USB_SET_DATA_ADDRESS(nand_in->start,hDevice);
			JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
			JZ4740_USB_NAND_OPS(temp,hDevice);
			ReadFile(hDevice, ret, 8, &nRead, NULL);
			printf(" Finish! ");
		switch (nand_in->option)
		{
		case OOB_ECC:
			JZ4740_USB_SET_DATA_ADDRESS(nand_in->start,hDevice);					//Read back to check!
			JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
			temp = ((OOB_ECC<<12) & 0xf000) +((i<<4) & 0xff0) + NAND_READ;
			JZ4740_USB_NAND_OPS(temp,hDevice);
			printf("Checking...");			
			ReadFile(hDevice, check_buf, page_num * (Hand.nand_ps + Hand.nand_os), &nRead, NULL);
			ReadFile(hDevice, ret, 8, &nRead, NULL);
			break;
		case OOB_NO_ECC:			//do not support data verify
			JZ4740_USB_SET_DATA_ADDRESS(nand_in->start,hDevice);					//Read back to check!
			JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
			temp = ((OOB_NO_ECC<<12) & 0xf000) +((i<<4) & 0xff0) + NAND_READ;
			JZ4740_USB_NAND_OPS(temp,hDevice);
			printf("Checking...");			
			ReadFile(hDevice, check_buf, page_num * (Hand.nand_ps + Hand.nand_os), &nRead, NULL);
			ReadFile(hDevice, ret, 8, &nRead, NULL);
			break;
		case NO_OOB:
			JZ4740_USB_SET_DATA_ADDRESS(nand_in->start,hDevice);					//Read back to check!
			JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
			temp = ((NO_OOB<<12) & 0xf000) +((i<<4) & 0xff0) + NAND_READ;
			JZ4740_USB_NAND_OPS(temp,hDevice);
			printf("Checking...");
			ReadFile(hDevice, check_buf, page_num * Hand.nand_ps , &nRead, NULL);
			ReadFile(hDevice, ret, 8, &nRead, NULL);
			break;
		default:;
		}
#if 1
		if (nand_in->start < 1 && Hand.nand_ps == 4096 && Hand.fw_args.cpu_id == 0x4740)
		{
//			(nand_out->status)[i] = 1;
			printf(" no check!");
			cur_page = (ret[3]<<24)|(ret[2]<<16)|(ret[1]<<8)|(ret[0]<<0);
			printf(" End at %d ",cur_page);
			continue;
		}
#endif
			if (nand_in->Check(nand_in->buf,check_buf,nand_in->length)) 
			{
//				(nand_out->status)[i] = 1;
				printf(" pass!");
				cur_page = (ret[3]<<24)|(ret[2]<<16)|(ret[1]<<8)|(ret[0]<<0);
				printf(" End at %d ",cur_page);
			}
			else 
			{
//				(nand_out->status)[i] = 0;
				printf(" fail!");
				NAND_IN bad;
				cur_page = (ret[3]<<24)|(ret[2]<<16)|(ret[1]<<8)|(ret[0]<<0);
				printf(" End at %d ",cur_page);
				bad.start = (cur_page - 1)/ Hand.nand_ppb;
				if (cur_page % Hand.nand_ppb==0)
					API_Nand_Markbad( &bad );
			}

	}
	Handle_Close();
	return cur_page;
}

int API_SD_Program_Check(NAND_IN *nand_in,NAND_OUT *nand_out)
{
	unsigned int i,page_num,cur_page;
	unsigned short temp;
	unsigned char status_buf[32];

	if (nand_in->length > (unsigned int)MAX_TRANSFER_SIZE)
	{
		printf("\n Buffer size too long!");
		return -1;
	}

	if (Handle_Open(nand_in->dev)==-1)
	{
		printf("\n Can not connect device!");
		return -1;
	}
	if (API_IsBoot() < 3)
	{
		printf("\n Device unboot! Boot it first!");
		return -1;
	}
	WriteFile(hDevice, nand_in->buf, nand_in->length , &nWritten, NULL);

	page_num = nand_in->length / 512;

	temp = ((nand_in->option<<12) & 0xf000)  + ((i<<4) & 0xff0) + SD_PROGRAM;	
	JZ4740_USB_SET_DATA_ADDRESS(nand_in->start,hDevice);
	JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
	JZ4740_USB_NAND_OPS(temp,hDevice);
	ReadFile(hDevice, ret, 8, &nRead, NULL);
	printf(" Finish! ");

	Handle_Close();
	return cur_page;
}





int API_Read_Nand_To_Ram(NAND_IN *nand_in,unsigned int ram_addr)
{
	unsigned int i,temp;
	unsigned char csn;

		if (Handle_Open(nand_in->dev)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}

		if (nand_in->start > NAND_MAX_PAGE_NUM || nand_in->length > NAND_MAX_PAGE_NUM )
		{
			printf("\n Page number overflow!");
			return -1;
		}
		if (API_IsBoot() < 3)
		{
			printf("\n Device unboot! Boot it first!");
			return -1;
		}
		for (i=0;i<nand_in->max_chip;i++) 
			if ((nand_in->cs_map)[i]!=0) break;
		if (i>=nand_in->max_chip) return 1;
		csn = i;

	printf("\n Reading from flash to ram of No.%d device No.%d flash....",nand_in->dev,csn);
	JZ4740_USB_PROG_START1(ram_addr,hDevice);
	JZ4740_USB_SET_DATA_ADDRESS(nand_in->start,hDevice);
	JZ4740_USB_SET_DATA_LENGTH(nand_in->length,hDevice);
	temp = ((NO_OOB<<12) & 0xf000) + ((csn<<4) & 0xff0) + NAND_READ_TO_RAM;
	JZ4740_USB_NAND_OPS(temp,hDevice);
	ReadFile(hDevice, ret, 8, &nRead, NULL);
	Handle_Close();

	return 1;
}

int API_Nand_Make(NAND_IN * nand_in,char *fname)
{
	int flen,m,j,k;
	FILE *fp;
	unsigned short temp;
	unsigned int start_addr,page_num,offset;
	if (Handle_Open(nand_in->dev)==-1)
	{
		printf("\n Can not connect device!");
		return -1;
	}
	if (API_IsBoot() < 3)
	{
		printf("\n Device unboot! Boot it first!");
		return -1;
	}
	fp=fopen(fname,"w+b");
	if (fp==NULL)
	{
		printf("\n Can not open file !");
		return 0;
	}
	fseek(fp,0,SEEK_SET);		//file point return to begin
//	flen = nand_in->length * (Hand.nand_ps + Hand.nand_os);
	flen = nand_in->length * Hand.nand_ps;

	m = flen / MAX_TRANSFER_SIZE;
	j = flen % MAX_TRANSFER_SIZE;
	start_addr = nand_in->start;
	offset = 0;
	for (k=0;k<m;k++)
	{
//		page_num = MAX_TRANSFER_SIZE / (Hand.nand_ps + Hand.nand_os);
		page_num = MAX_TRANSFER_SIZE / Hand.nand_ps ;

		JZ4740_USB_SET_DATA_ADDRESS(start_addr,hDevice);
		JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
//		temp = ((OOB_ECC<<12) & 0xf000) + (( 0 <<4) & 0xff0) + NAND_READ;
		temp = ((NO_OOB<<12) & 0xf000) + (( 0 <<4) & 0xff0) + NAND_READ;
		//printf("\n temp %x",temp);
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, nand_in->buf, MAX_TRANSFER_SIZE, &nRead, NULL);
		ReadFile(hDevice, ret, 8, &nRead, NULL);
		fwrite(nand_in->buf, 1 ,MAX_TRANSFER_SIZE,fp);
		start_addr += page_num;
		offset += MAX_TRANSFER_SIZE ;
		fseek(fp,offset,SEEK_SET);
	}

	if (j)
	{
//		page_num = j/ (Hand.nand_ps + Hand.nand_os);
		page_num = j/ Hand.nand_ps ;
		JZ4740_USB_SET_DATA_ADDRESS(start_addr,hDevice);
		JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
		temp = ((NO_OOB<<12) & 0xf000) + (( 0 <<4) & 0xff0) + NAND_READ;
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, nand_in->buf, j, &nRead, NULL);
		ReadFile(hDevice, ret, 8, &nRead, NULL);
		fwrite(nand_in->buf, 1 ,j,fp);
	}

	fclose(fp);
	Handle_Close();
	return 1;
}

int API_Sdram_Load(SDRAM_IN *sdram_in)
{

	if (Handle_Open(sdram_in->dev)==-1)
	{
		printf("\n Can not connect device!");
		return -1;
	}
	if (API_IsBoot() < 3)
	{
		printf("\n Device unboot! Boot it first!");
		return -1;
	}
	if (sdram_in->length > (unsigned int) MAX_LOAD_SIZE)
	{
		printf("\n Image length too long!");
		return -1;
	}

	WriteFile(hDevice, sdram_in->buf, sdram_in->length , &nWritten, NULL);
	JZ4740_USB_SET_DATA_ADDRESS(sdram_in->start,hDevice);
	JZ4740_USB_SET_DATA_LENGTH(sdram_in->length,hDevice);
	JZ4740_USB_SDRAM_OPS(SDRAM_LOAD,hDevice);
	ReadFile(hDevice, ret, 8, &nRead, NULL);
	//printf("\n Load last address at %x ",((ret[3]<<24)|(ret[2]<<16)|(ret[1]<<8)|(ret[0]<<0)));
	Handle_Close();
	return 1;
}

int API_Sdram_Load_File(SDRAM_IN * sdram_in,char *fname)
{
	unsigned int flen,m,j,offset,k;
	FILE *fp;

	fp=fopen(fname,"rb");
	if (fp==NULL)
	{
		printf("\n Can not open file !");
		return -1;
	}
	fseek(fp,0,SEEK_END);
	flen=ftell(fp);
	
	m = flen / MAX_LOAD_SIZE;
	j = flen % MAX_LOAD_SIZE;
	fseek(fp,0,SEEK_SET);		//file point return to begin
	offset = 0;
	printf("\n Total size to send in byte is :%d",flen);
	printf("\n Loading data to SDRAM : ");

	
	for (k=0;k<m;k++)
	{
		fread(sdram_in->buf,1,MAX_LOAD_SIZE,fp);			//read code from file to buffer
		sdram_in->length = MAX_LOAD_SIZE;
		API_Sdram_Load(sdram_in);
		sdram_in->start += MAX_LOAD_SIZE;
		offset += MAX_LOAD_SIZE;
		fseek(fp,offset,SEEK_SET);
		if ( k % 60 == 0) printf("\n ");
		printf("#");
	}

	if (j)
	{
		if (j % 4 !=0) j += 4-(j%4);
		fread(sdram_in->buf,1,j,fp);
		sdram_in->length = j;
		API_Sdram_Load(sdram_in);
		printf("#");
	}
	fclose(fp);
	return 1;
}

////////////////////////////////////////////////////////////////////////
// JZ4740_USB_IOCTL_GET_CPU_INFO
//
//		Test one Io Control Code
//
// TODO:
//		Pass appropriate arguments to your device and check
//		the return value
//
int JZ4740_USB_GET_CPU_INFO(HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//Handle_connect();
	// Call device IO Control interface (JZ4740_USB_IOCTL_GET_CPU_INFO) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_GET_CPU_INFO,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	bufOutput[8] = '\0';
	//printf("\n CPU INFO = %s", bufOutput);
	if (!strcmp(bufOutput,"JZ4740V1")) return 1;
	if (!strcmp(bufOutput,"JZ4750V1")) return 2;
	if (!strcmp(bufOutput,"Boot4740")) return 3;
	if (!strcmp(bufOutput,"Boot4750")) return 4;
	return 0;
}

////////////////////////////////////////////////////////////////////////
// JZ4740_USB_IOCTL_SET_DATA_ADDRESS
//
//		Test one Io Control Code
//
// TODO:
//		Pass appropriate arguments to your device and check
//		the return value
//
int JZ4740_USB_SET_DATA_ADDRESS(unsigned int addr,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput
	/*if (hDevice == INVALID_HANDLE_VALUE) 
	{
			hDevice = OpenByInterface( &ClassGuid, 0, &Error);
			if (hDevice == INVALID_HANDLE_VALUE) 
			{
				printf("\n Can not open device!");
				printf("\n Operation can not carry out until USB connect is ok!");
				return -1;
			}
	}*/
	//if (Handle_connect()!=1) return -1;
	//printf("Set ADDR 0x%x\n", addr);
	*(unsigned int *)bufInput = addr;

	// Call device IO Control interface (JZ4740_USB_IOCTL_SET_DATA_ADDRESS) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_SET_DATA_ADDRESS,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1;
}

////////////////////////////////////////////////////////////////////////
// JZ4740_USB_IOCTL_SET_DATA_LENGTH
//
//		Test one Io Control Code
//
// TODO:
//		Pass appropriate arguments to your device and check
//		the return value
//
int JZ4740_USB_SET_DATA_LENGTH(unsigned int len,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//if (Handle_connect()!=1) return -1;
	//printf("Set LEN %d\n", len);
	*(unsigned int *)bufInput = len;

	// Call device IO Control interface (JZ4740_USB_IOCTL_SET_DATA_LENGTH) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_SET_DATA_LENGTH,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1;
}

////////////////////////////////////////////////////////////////////////
// JZ4740_USB_IOCTL_FLUSH_CACHES
//
//		Test one Io Control Code
//
// TODO:
//		Pass appropriate arguments to your device and check
//		the return value
//
int JZ4740_USB_FLUSH_CACHES(HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//printf("\n FLUSH_CACHES");
	//Handle_connect();
	// Call device IO Control interface (JZ4740_USB_IOCTL_FLUSH_CACHES) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_FLUSH_CACHES,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1;
}

////////////////////////////////////////////////////////////////////////
// JZ4740_USB_IOCTL_PROG_START1
//
//		Test one Io Control Code
//
// TODO:
//		Pass appropriate arguments to your device and check
//		the return value
//
int JZ4740_USB_PROG_START1(unsigned int addr,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//printf("PROG_START1\n");
	*(unsigned int *)bufInput = addr;
	// Call device IO Control interface (JZ4740_USB_IOCTL_PROG_START1) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_PROG_START1,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1;
}

////////////////////////////////////////////////////////////////////////
// JZ4740_USB_IOCTL_PROG_START2
//
//		Test one Io Control Code
//
// TODO:
//		Pass appropriate arguments to your device and check
//		the return value
//
int JZ4740_USB_PROG_START2(unsigned int addr,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//printf("PROG_START2\n");
	*(unsigned int *)bufInput = addr;

	// Call device IO Control interface (JZ4740_USB_IOCTL_PROG_START2) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_PROG_START2,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1;
}


int JZ4740_USB_NOR_OPS(unsigned int ops,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	*(unsigned int *)bufInput = ops;

	// Call device IO Control interface (JZ4740_USB_IOCTL_SET_DATA_ADDRESS) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_NOR_OPS,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1;
}


int JZ4740_USB_NAND_OPS(unsigned int ops,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//printf("Set NAND_OPS 0x%x\n", ops);
	*(unsigned int *)bufInput = ops;

	// Call device IO Control interface (JZ4740_USB_IOCTL_SET_DATA_ADDRESS) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_NAND_OPS,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	//bufOutput[9] = '\0';
	return 1;
	//(bufOutput[6]<<8) + bufOutput[7];
}


int JZ4740_USB_CONFIGRATION(unsigned int ops,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//printf("Configration 0x%x\n", ops);
	*(unsigned int *)bufInput = ops;

	// Call device IO Control interface (JZ4740_USB_IOCTL_SET_DATA_ADDRESS) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_CONFIGRATION,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1; 
		//(bufOutput[6]<<8) + bufOutput[7];
}

int JZ4740_USB_GET_NUM(HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//Handle_connect();
	// Call device IO Control interface (JZ4740_USB_IOCTL_GET_CPU_INFO) in driver
	//printf("Issuing Ioctl to device - GET_NUM");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_GET_NUM,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return bufOutput[0];
	//printf("\n CPU INFO = %s", bufOutput);
	//return 1;
}

int JZ4740_USB_SDRAM_OPS(unsigned int ops,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//printf("Set NAND_OPS 0x%x\n", ops);
	*(unsigned int *)bufInput = ops;

	// Call device IO Control interface (JZ4740_USB_IOCTL_SET_DATA_ADDRESS) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_SDRAM_OPS,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	//bufOutput[9] = '\0';
	return 1;
	//(bufOutput[6]<<8) + bufOutput[7];
}
